const AsyncLock = require("async-lock");
const { scheduleLoopTask, sleep, fileExists } = require("./utils/run.js");
const { log } = require("./utils/log.js");
const OkxClient = require("./clients/okx.js");
const StatOrderService = require("./services/statOrder.js");
const LimiterService = require("./services/limiter.js");
const TgService = require("./services/tg.js");
const cfgFile = `./configs/config.json`;
if (!fileExists(cfgFile)) {
    log(`config file ${cfgFile} does not exits`);
    process.exit();
}
const configs = require(cfgFile);

const { account } = require("minimist")(process.argv.slice(2));
if (account == null) {
    log("node stat.js --account=xxx");
    process.exit();
}

const keyIndex = configs.keyIndexMap[account];
// 加载.env文件
const dotenv = require("dotenv");
dotenv.config();
const apiKeyArr = process.env.OKX_STAT_API_KEY.split(",");
const apiSecretArr = process.env.OKX_STAT_API_SECRET.split(",");
const apiPasswordArr = process.env.OKX_STAT_API_PASSWORD.split(",");

let options = {
    API_KEY: apiKeyArr[keyIndex],
    API_SECRET: apiSecretArr[keyIndex],
    API_PASSWORD: apiPasswordArr[keyIndex],
    market: configs.market[account],
    localAddress: configs.okxLocalAddress[account],
};
const exchangeClient = new OkxClient(options);

// 初始化同步锁
const lock = new AsyncLock();

// 初始化stat order service
const statOrderService = new StatOrderService();
const tgService = new TgService();
const limiter = new LimiterService(2, 24 * 60 * 60 * 1000);
let noOrders = 0;
let maxNoOrdersTime = 5;
let highLeverageAcctCfg = configs.highLeverageAcct[account];
let closePositionFlag = false;

let volContractMap = {};
const loadVolContractInfo = async () => {
    let insts = await exchangeClient.getInstruments("SWAP");
    insts = insts.filter((item) => item.instID.indexOf("USDC") == -1);
    for (let inst of insts) {
        volContractMap[inst.instID] = parseFloat(inst.ctVal);
    }
};

const positionUpdateHandler = async (positions) => {
    for (let pos of positions) {
        const diffPrice = Math.abs(pos.liqPrice - pos.markPrice);
        const diffRatio = diffPrice / pos.liqPrice;

        if (diffRatio <= highLeverageAcctCfg.priceThres) {
            log(
                `${pos.symbol} markPrice:${pos.markPrice} liqPrice:${pos.liqPrice} diffRatio:${diffRatio} priceThreshold:${highLeverageAcctCfg.priceThres}`
            );

            // 获取当前position，市价平仓
            if (!closePositionFlag) {
                await closePositions();
            }
            closePositionFlag = true;
        }
    }
};

const orderUpdateHandler = async (orders) => {
    for (let order of orders) {
        // 使用clientOrderId作为锁的key，避免并发引起的更新错误
        const clientOrderId = order.clientOrderId;
        await lock.acquire(clientOrderId, async () => {
            if (["FILLED"].includes(order.orderStatus)) {
                const symbol = order.symbol;
                if (!volContractMap.hasOwnProperty(symbol)) {
                    console.error(`${symbol}'s ctVal configuration is missing`);
                    return;
                }

                const side = order.side;
                const quantity = order.originalQuantity;
                const amount = quantity * parseFloat(volContractMap[symbol]);
                const price = order.lastFilledPrice;
                const notional = price * amount;
                const maker = order.isMaker;

                const msg = `${account} ${clientOrderId} ${symbol} ${side} ${order.orderStatus} ${amount}@${price} Maker(${maker})`;
                log(msg);

                // 将订单写入数据库
                await statOrderService.saveOrder(`tb_order_${account}`, {
                    symbol,
                    side,
                    quantity,
                    amount,
                    price,
                    notional,
                    maker,
                });
            }
        });
    }
};

const scheduleStatProfit = () => {
    scheduleLoopTask(async () => {
        try {
            const tickersMap = await exchangeClient.getFuturesTickers();
            const balances = await exchangeClient.getFuturesBalances();
            let usdtBalanceArr = balances
                .filter((item) => item.asset == "USDT")
                .map((item) => item.balance);
            const usdtBalance =
                usdtBalanceArr.length == 0 ? 0 : usdtBalanceArr[0];

            let tradingBalance = balances.reduce((total, item) => {
                return total + parseFloat(item.notional);
            }, 0);

            const fundingBalanceArr =
                await exchangeClient.getFundingAccountBalances();
            let fundingBalance = fundingBalanceArr.reduce((total, item) => {
                if (item.asset == "USDT") {
                    return total + parseFloat(item.balance);
                } else {
                    return (
                        total +
                        parseFloat(item.balance) *
                            parseFloat(
                                tickersMap[item.asset + "-USDT-SWAP"]["bestBid"]
                            )
                    );
                }
            }, 0);
            log(
                `tradingBalance=${tradingBalance}, fundingBalance=${fundingBalance}`
            );

            const positions = await exchangeClient.getPositions();
            let notionalBTCETH = 0;
            let notionalOther = 0;
            let positionsNum = 0;
            if (positions != null) {
                for (let position of positions) {
                    positionsNum++;
                    if (
                        ["ETH-USDT-SWAP", "BTC-USDT-SWAP"].includes(
                            position.symbol
                        )
                    ) {
                        notionalBTCETH += position.notional;
                    } else {
                        notionalOther += position.notional;
                    }
                }
            }
            const notionalAll = notionalBTCETH + notionalOther;
            let msg = `${account} USDTBalance=${usdtBalance.toFixed(
                2
            )}|PositionDeltaWithBTCETH=${notionalBTCETH.toFixed(
                2
            )}|PositionDeltaWithoutBTCETH$=${notionalOther.toFixed(
                2
            )}|PositionDeltaAll=${notionalAll.toFixed(
                2
            )}|PositionCount=${positionsNum}`;
            log(msg);

            // 获取margin ratio
            let marginRatio = await exchangeClient.getMarginRatio();
            marginRatio = marginRatio ? marginRatio : 0;

            // 获取openorders数量
            let buyOrdersNum = 0;
            let sellOrdersNum = 0;
            const orders = await exchangeClient.getFuturesOpenOrderList();
            if (orders && orders.length > 1) {
                for (let order of orders) {
                    if (order.side == "BUY") {
                        buyOrdersNum++;
                    } else {
                        sellOrdersNum++;
                    }
                }
                noOrders = 0;
                maxNoOrdersTime = 5;
            } else {
                noOrders++;
                if (noOrders >= maxNoOrdersTime) {
                    if (account != "dcs008" && account != "sma004") {
                        // 报警
                        tgService.sendMsg(`${account} orders numbers warning`);
                        noOrders = 0;
                        maxNoOrdersTime = 2 * maxNoOrdersTime;
                    }
                }
            }

            const ordersNum = buyOrdersNum + sellOrdersNum;
            console.log(
                `The num of open orders is ${ordersNum}(B:${buyOrdersNum}|S:${sellOrdersNum})`
            );

            // 将订单写入数据库
            await statOrderService.saveBalance({
                account,
                usdt_balance: usdtBalance.toFixed(2),
                trading_balance: tradingBalance.toFixed(2),
                funding_balance: fundingBalance.toFixed(2),
                btc_eth_delta: notionalBTCETH.toFixed(2),
                other_delta: notionalOther.toFixed(2),
                total_delta: notionalAll.toFixed(2),
                margin_ratio: marginRatio.toFixed(2),
                orders_num: ordersNum,
                position_count: positionsNum,
            });
        } catch (e) {
            console.error(e);
        }
        await sleep(120 * 1000);
    });
};

const scheduleTransferFund = async () => {
    scheduleLoopTask(async () => {
        try {
            const { usdtBalance, availableUsdtBalance } =
                await getUSDTBalance();
            if (
                usdtBalance >
                    highLeverageAcctCfg.initUsdtBalance +
                        highLeverageAcctCfg.transferThres &&
                availableUsdtBalance > highLeverageAcctCfg.transferThres
            ) {
                // USDT 盈利超过了Threshold，发起平仓 + 划转功能
                log(
                    `[!!!] usdtBalance=${usdtBalance}, availableUsdtBalance=${availableUsdtBalance}, transferThres=${highLeverageAcctCfg.transferThres}`
                );

                // 获取当前position，市价平仓
                await closePositions();

                // 从trading账户中，转transferThres 到funding账户中
                log(
                    `transfer ${highLeverageAcctCfg.transferThres} USDT from trading account to funding account`
                );
                await exchangeClient.trasferAsset(
                    "Trading",
                    "Funding",
                    "USDT",
                    highLeverageAcctCfg.transferThres
                );

                await sleep(1000);
                const newBalance = await getUSDTBalance();
                const fBalances =
                    await exchangeClient.getFundingAccountBalances();
                const fUsdtBalance = fBalances[0] ? fBalances[0].balance : 0;

                const newPositions = await exchangeClient.getPositions();
                console.log(
                    `Trading Account USDT Balace: ${newBalance.usdtBalance}, Funding Account USDT Balance: ${fUsdtBalance}`
                );
                if (newPositions.length > 0) {
                    console.log("Current Positions:");
                    for (let pos of newPositions) {
                        console.log(`${pos.symbol} ${pos.positionAmt}`);
                    }
                } else {
                    console.log("Current No Positions");
                }
            }
        } catch (e) {
            console.error(e);
        }
        await sleep(60 * 1000);
    });
};

const getUSDTBalance = async () => {
    const balances = await exchangeClient.getFuturesBalances();
    let usdtBalanceArr = balances.filter((item) => item.asset == "USDT");

    let usdtBalItem = usdtBalanceArr.length == 0 ? {balance: 0, availableBal:0} : usdtBalanceArr[0];

    return {
        usdtBalance: usdtBalItem.balance,
        availableUsdtBalance: usdtBalItem.availableBal,
    };
};

const closePositions = async () => {
    const positions = await exchangeClient.getPositions();
    for (let pos of positions) {
        if (pos.positionAmt != 0) {
            const side = pos.positionAmt > 0 ? "SELL" : "BUY";
            const symbol = pos.symbol;
            const quantity = Math.abs(pos.positionAmt);
            log(
                `close ${symbol} position ${pos.positionAmt} to place market order ${side}, ${quantity}`
            );
            await exchangeClient.placeReduceOnlyMarketOrder(side, symbol, quantity);
        }
    }
};

const scheduleRiskControl = async () => {
    scheduleLoopTask(async () => {
        try {
            const marginRatio = await exchangeClient.getMarginRatio();
            if (marginRatio <= 1.03) {
                // 获取当前position，市价平仓
                if (!closePositionFlag) {
                    await closePositions();
                }
                closePositionFlag = true;
            }
        } catch (e) {
            console.error(e);
        }
        await sleep(5 * 1000);
    });
};

const scheduleRefund = async () => {
    scheduleLoopTask(async () => {
        try {
            // 当有过平仓操作之后，才会进入逻辑里面
            if (closePositionFlag) {
                // 没有达到操作上限才可以继续进行
                if (limiter.canPerformAction()) {
                    // 获取Trading Account USDT 余额
                    const { usdtBalance, availableUsdtBalance } =
                        await getUSDTBalance();

                    if (usdtBalance < 0) {
                        log(`NOT ReFund, because Trading Account Balance is less than 0 ${usdtBalance}`)
                        return;
                    }

                    // 获取funding Account USDT 余额
                    const fBalances =
                        await exchangeClient.getFundingAccountBalances();
                    const fUsdtBalance = fBalances[0]
                        ? fBalances[0].balance
                        : 0;

                    const diff =
                        highLeverageAcctCfg.initUsdtBalance - usdtBalance;
                    log(
                        `Trading Account USDT Balance ${usdtBalance}, Funding Account USDT Balance ${fUsdtBalance}`
                    );
                    if (diff > 0 && fUsdtBalance > diff) {
                        log(
                            `Transfer ${diff} USDT From Funding Account to Trading Account`
                        );
                        await exchangeClient.trasferAsset(
                            "Funding",
                            "Trading",
                            "USDT",
                            diff
                        );
                        limiter.performAction();
                        closePositionFlag = false;
                    }
                }
            }
        } catch (e) {
            console.error(e);
        }
        await sleep(5 * 1000);
    });
};

const main = async () => {
    await loadVolContractInfo();
    exchangeClient.initWsEventHandler({
        orders: orderUpdateHandler,
        positions: positionUpdateHandler,
    });
    exchangeClient.wsFuturesOrders();
    exchangeClient.wsFuturesPositions();
    scheduleStatProfit();
    scheduleTransferFund();
    scheduleRiskControl();
    scheduleRefund();
};
main();
